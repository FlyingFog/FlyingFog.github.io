# Introduction to Smart Contracts

## Example

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16 <0.9.0;

contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public view returns (uint) {
        return storedData;
    }
}
```

- The first line tells you that the source code is licensed under the GPL version 3.0. 机器可读的license 
- The next line specifies that the source code is written for Solidity version 0.4.16, or a newer version of the language up to, but not including version 0.9.0. Pragmas are common instructions for compilers about how to treat the source code。
- The line `uint storedData;` declares a state variable called `storedData` of type `uint` (unsigned *int*eger of *256* bits). You can think of it as a single slot in a database that you can query and alter by calling functions of the code that manages the database. In this example, the contract defines the functions `set` and `get` that can be used to modify or retrieve the value of the variable.
- 获取a member (like a state variable) of the current contract，不需要特别地添加`this.`，you just access it directly via its name. 

>所有的标识符（合约名称，函数名称和变量名称）都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储。

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

contract Coin {
    // The keyword "public" makes variables
    // accessible from other contracts
    address public minter;
    mapping (address => uint) public balances;

    // Events allow clients to react to specific
    // contract changes you declare
    event Sent(address from, address to, uint amount);

    // Constructor code is only run when the contract
    // is created
    constructor() {
        minter = msg.sender;
    }

    // Sends an amount of newly created coins to an address
    // Can only be called by the contract creator
    function mint(address receiver, uint amount) public {
        require(msg.sender == minter);
        balances[receiver] += amount;
    }

    // Errors allow you to provide information about
    // why an operation failed. They are returned
    // to the caller of the function.
    error InsufficientBalance(uint requested, uint available);

    // Sends an amount of existing coins
    // from any caller to an address
    function send(address receiver, uint amount) public {
        if (amount > balances[msg.sender])
            revert InsufficientBalance({
                requested: amount,
                available: balances[msg.sender]
            });

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}
```

- `address public minter;` 这一行声明了一个可以被公开访问的 `address` 类型的状态变量， `address` 类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对

- The keyword `public` automatically generates a function that allows you to access the current value of the state variable from outside of the contract. Without this keyword, other contracts have no way to access the variable. The code of the function generated by the compiler is equivalent to the following 

  ```
  function minter() external view returns (address) { return minter; }
  ```

- 下一行， `mapping (address => uint) public balances;` 也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 [哈希表](https://en.wikipedia.org/wiki/Hash_table) 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。 因此，要么记住你添加到mapping中的数据（使用列表或更高级的数据类型会更好），要么在不需要键列表或值列表的上下文中使用它，就如本例。mapping 不能通过for找到key和value，只能做映射。

- The [getter function](https://docs.soliditylang.org/en/v0.8.13/contracts.html#getter-functions) created by the `public` keyword is more complex in the case of a mapping. It looks like the following:

  ```
  function balances(address account) external view returns (uint) {
      return balances[account];
  }
  ```

  你可以通过该函数轻松地查询到账户的余额。

- `event Sent(address from, address to, uint amount);` 这行声明了一个“事件（event）”，它会在 `send` 函数的最后一行被发出。用户界面（当然也包括服务器应用程序）可以监听区块链上正在发送的事件，而不会花费太多成本。一旦它被发出，监听该事件的listener都将收到通知。而所有的事件都包含了 `from` ， `to` 和 `amount` 三个参数，可方便追踪事务。 To listen for this event, you could use the following JavaScript code, which uses [web3.js](https://github.com/ethereum/web3.js/) to create the `Coin` contract object, and any user interface calls the automatically generated `balances` function from above：

  ```
  Coin.Sent().watch({}, '', function(error, result) {
      if (!error) {
          console.log("Coin transfer: " + result.args.amount +
              " coins were sent from " + result.args.from +
              " to " + result.args.to + ".");
          console.log("Balances now:\n" +
              "Sender: " + Coin.balances.call(result.args.from) +
              "Receiver: " + Coin.balances.call(result.args.to));
      }
  })
  ```

- The [constructor](https://docs.soliditylang.org/en/v0.8.13/contracts.html#constructor) is a special function that is executed during the creation of the contract and cannot be called afterwards. In this case, it permanently stores the address of the person creating the contract. The `msg` variable (together with `tx` and `block`) is a [special global variable](https://docs.soliditylang.org/en/v0.8.13/units-and-global-variables.html#special-variables-functions) that contains properties which allow access to the blockchain. `msg.sender` is always the address where the current (external) function call came from.
- The functions that make up the contract, and that users and contracts can call are `mint` and `send`.
- The `mint` function sends an amount of newly created coins to another address. The [require](https://docs.soliditylang.org/en/v0.8.13/control-structures.html#assert-and-require) function call defines conditions that reverts all changes if not met. In this example, `require(msg.sender == minter);` ensures that only the creator of the contract can call `mint`. In general, the creator can mint as many tokens as they like, but at some point, this will lead to a phenomenon called “overflow”. Note that because of the default [Checked arithmetic](https://docs.soliditylang.org/en/v0.8.13/control-structures.html#unchecked), the transaction would revert if the expression `balances[receiver] += amount;` overflows, i.e., when `balances[receiver] + amount` in arbitrary precision arithmetic is larger than the maximum value of `uint` (`2**256 - 1`). This is also true for the statement `balances[receiver] += amount;` in the function `send`.
- [Errors](https://docs.soliditylang.org/en/v0.8.13/contracts.html#errors) allow you to provide more information to the caller about why a condition or operation failed.
- The `send` function can be used by anyone (who already has some of these coins) to send coins to anyone else. If the sender does not have enough coins to send, the `if` condition evaluates to true. As a result, the `revert` will cause the operation to fail while providing the sender with error details using the `InsufficientBalance` error.

